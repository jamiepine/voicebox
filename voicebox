#!/usr/bin/env python3
"""
voicebox — self-contained CLI for talking to a Voicebox backend server.

No dependencies beyond the Python 3 standard library.

Configuration (env vars):
  VOICEBOX_URL   Full server URL, e.g. http://10.0.0.5:17493
  VOICEBOX_HOST  Server host/IP (default: 127.0.0.1). Ignored if VOICEBOX_URL is set.
  VOICEBOX_PORT  Server port (default: 17493). Ignored if VOICEBOX_URL is set.
"""

import argparse
import json
import os
import shutil
import signal
import subprocess
import sys
import time
import urllib.error
import urllib.request
from pathlib import Path

DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 17493
SERVER_BIN = "/Applications/Voicebox.app/Contents/MacOS/voicebox-server"
DEFAULT_DATA_DIR = Path.home() / "Library/Application Support/sh.voicebox.app"
PID_FILE = Path.home() / ".voicebox.pid"
LOG_FILE = Path.home() / ".voicebox.log"


def resolve_base_url(args):
    """Determine server URL from env vars and CLI flags."""
    if os.environ.get("VOICEBOX_URL"):
        return os.environ["VOICEBOX_URL"].rstrip("/")
    host = os.environ.get("VOICEBOX_HOST", DEFAULT_HOST)
    port = os.environ.get("VOICEBOX_PORT", str(DEFAULT_PORT))
    if hasattr(args, "port") and args.port != DEFAULT_PORT:
        port = str(args.port)
    return f"http://{host}:{port}"


# --- HTTP helpers (stdlib only, no requests) ---

def api(method, base_url, path, json_body=None, file_data=None, timeout=30):
    """Make an API call. Returns (status, parsed_json_or_bytes)."""
    url = f"{base_url}{path}"

    if file_data:
        # multipart upload
        boundary = f"----voiceboxboundary{int(time.time())}"
        filename, file_bytes, content_type = file_data
        body = (
            f"--{boundary}\r\n"
            f'Content-Disposition: form-data; name="file"; filename="{filename}"\r\n'
            f"Content-Type: {content_type}\r\n\r\n"
        ).encode() + file_bytes + f"\r\n--{boundary}--\r\n".encode()
        req = urllib.request.Request(url, data=body, method=method.upper())
        req.add_header("Content-Type", f"multipart/form-data; boundary={boundary}")
    elif json_body is not None:
        body = json.dumps(json_body).encode()
        req = urllib.request.Request(url, data=body, method=method.upper())
        req.add_header("Content-Type", "application/json")
    else:
        req = urllib.request.Request(url, method=method.upper())

    try:
        resp = urllib.request.urlopen(req, timeout=timeout)
        data = resp.read()
        ct = resp.headers.get("Content-Type", "")
        if "application/json" in ct:
            return resp.status, json.loads(data)
        return resp.status, data
    except urllib.error.HTTPError as e:
        body = e.read().decode(errors="replace")
        try:
            detail = json.loads(body).get("detail", body[:200])
        except Exception:
            detail = body[:200]
        print(f"Error: {e.code} — {detail}", file=sys.stderr)
        sys.exit(1)
    except urllib.error.URLError as e:
        print(f"Error: cannot connect to server at {base_url}", file=sys.stderr)
        print("Start it with: voicebox server", file=sys.stderr)
        sys.exit(1)


def api_get_json(base_url, path, timeout=30):
    _, data = api("GET", base_url, path, timeout=timeout)
    return data


# --- Subcommands ---

def cmd_server(args):
    """Start the backend server (no frontend)."""
    data_dir = args.data_dir or str(DEFAULT_DATA_DIR)
    port = str(args.port)

    if args.stop:
        _stop_server()
        return

    if Path(SERVER_BIN).exists():
        bin_path = SERVER_BIN
    elif shutil.which("voicebox-server"):
        bin_path = "voicebox-server"
    else:
        bin_path = None

    cmd = ([bin_path, "--data-dir", data_dir, "--port", port] if bin_path
           else [sys.executable, "-m", "backend.main", "--port", port])

    if args.detach:
        if PID_FILE.exists():
            pid = int(PID_FILE.read_text().strip())
            try:
                os.kill(pid, 0)
                print(f"Server already running (pid {pid})")
                return
            except ProcessLookupError:
                PID_FILE.unlink(missing_ok=True)

        log = open(LOG_FILE, "w")
        proc = subprocess.Popen(
            cmd,
            stdout=log,
            stderr=log,
            start_new_session=True,
            cwd=None if bin_path else str(Path(__file__).resolve().parent),
        )
        PID_FILE.write_text(str(proc.pid))
        print(f"Waiting for server (pid {proc.pid}, port {port})...", end="", flush=True)
        health_url = f"http://127.0.0.1:{port}/health"
        for _ in range(60):
            time.sleep(0.5)
            if proc.poll() is not None:
                print(" failed.")
                print(f"Server exited. Check log: {LOG_FILE}", file=sys.stderr)
                PID_FILE.unlink(missing_ok=True)
                sys.exit(1)
            try:
                r = urllib.request.urlopen(health_url, timeout=2)
                if r.status == 200:
                    print(" ready.")
                    print("Stop with: voicebox server --stop")
                    return
            except Exception:
                print(".", end="", flush=True)
        print(" timed out.")
        print(f"Server didn't respond within 30s. Check log: {LOG_FILE}", file=sys.stderr)
    else:
        print(f"Starting voicebox server on port {port}...")
        print(f"Data dir: {data_dir}")
        print("Press Ctrl+C to stop.\n")
        try:
            subprocess.run(
                cmd,
                cwd=None if bin_path else str(Path(__file__).resolve().parent),
            )
        except KeyboardInterrupt:
            print("\nServer stopped.")


def _stop_server():
    """Stop a detached server."""
    if not PID_FILE.exists():
        print("No server running (no pid file).")
        return
    pid = int(PID_FILE.read_text().strip())
    try:
        os.kill(pid, signal.SIGTERM)
        print(f"Stopped server (pid {pid})")
    except ProcessLookupError:
        print(f"Server not running (stale pid {pid})")
    PID_FILE.unlink(missing_ok=True)


def cmd_voices(args):
    """List all voice profiles."""
    profiles = api_get_json(args.url, "/profiles")
    if not profiles:
        print("No voice profiles found. Import one with: voicebox import <file.zip>")
        return
    print(f"{'Name':<30} {'Language':<10} {'ID'}")
    print("-" * 75)
    for p in profiles:
        print(f"{p['name']:<30} {p['language']:<10} {p['id']}")


def cmd_import(args):
    """Import a voice profile from a ZIP file."""
    zip_path = Path(args.file)
    if not zip_path.exists():
        print(f"Error: file not found: {zip_path}", file=sys.stderr)
        sys.exit(1)

    print(f"Importing {zip_path.name}...")
    file_bytes = zip_path.read_bytes()
    _, profile = api("POST", args.url, "/profiles/import",
                     file_data=(zip_path.name, file_bytes, "application/zip"),
                     timeout=60)
    print(f"Imported: {profile['name']} ({profile['id']})")


def cmd_generate(args):
    """Generate speech from text."""
    if args.text:
        text = args.text
    elif args.file:
        text = Path(args.file).read_text().strip()
    elif not sys.stdin.isatty():
        text = sys.stdin.read().strip()
    else:
        print("Error: provide text via --text, --file, or stdin.", file=sys.stderr)
        sys.exit(1)

    if not text:
        print("Error: text is empty.", file=sys.stderr)
        sys.exit(1)

    profile = resolve_profile(args.url, args.voice)

    payload = {
        "profile_id": profile["id"],
        "text": text,
        "language": args.language or profile.get("language", "en"),
    }
    if args.seed is not None:
        payload["seed"] = args.seed
    if args.instruct:
        payload["instruct"] = args.instruct

    print(f"Generating with voice '{profile['name']}'...")
    start = time.time()
    _, result = api("POST", args.url, "/generate", json_body=payload, timeout=300)
    elapsed = time.time() - start
    print(f"Done in {elapsed:.1f}s (audio duration: {result['duration']:.1f}s)")

    tag = str(int(time.time()))[-5:]
    wav_path = f"output_{tag}.wav"
    _, wav_data = api("GET", args.url, f"/audio/{result['id']}", timeout=60)
    Path(wav_path).write_bytes(wav_data)

    if not shutil.which("ffmpeg"):
        print("Warning: ffmpeg not found, keeping .wav", file=sys.stderr)
        output = wav_path
    else:
        output = args.output or f"output_{tag}.m4a"
        r = subprocess.run(
            ["ffmpeg", "-y", "-i", wav_path, "-c:a", "aac", "-b:a", "128k", output],
            capture_output=True,
        )
        if r.returncode != 0:
            print("Warning: ffmpeg failed, keeping .wav", file=sys.stderr)
            output = wav_path
        else:
            Path(wav_path).unlink()
            print(f"Saved: {output}")

    if not args.no_open:
        subprocess.run(["open", output])


def cmd_health(args):
    """Check server health."""
    h = api_get_json(args.url, "/health")
    print(f"Status:       {h['status']}")
    print(f"Model loaded: {h['model_loaded']}")
    print(f"Backend:      {h.get('backend_type', '?')}")
    print(f"GPU:          {h.get('gpu_type', 'none')}")
    if h.get("vram_used_mb"):
        print(f"VRAM used:    {h['vram_used_mb']:.0f} MB")


# --- Profile resolution ---

def resolve_profile(base_url, voice_name):
    profiles = api_get_json(base_url, "/profiles")
    if not profiles:
        print("Error: no voice profiles found.", file=sys.stderr)
        print("Import one with: voicebox import <file.zip>", file=sys.stderr)
        sys.exit(1)

    if voice_name:
        match = [p for p in profiles if p["name"].lower() == voice_name.lower()]
        if not match:
            match = [p for p in profiles if voice_name.lower() in p["name"].lower()]
        if not match:
            print(f"Error: no voice matching '{voice_name}'. Available:", file=sys.stderr)
            for p in profiles:
                print(f"  - {p['name']}", file=sys.stderr)
            sys.exit(1)
        if len(match) > 1:
            print(f"Multiple voices match '{voice_name}':", file=sys.stderr)
            for p in match:
                print(f"  - {p['name']}", file=sys.stderr)
            sys.exit(1)
        return match[0]
    else:
        print("Available voices:")
        for i, p in enumerate(profiles, 1):
            print(f"  {i}. {p['name']} ({p['language']})")
        print()
        while True:
            choice = input(f"Choose a voice [1-{len(profiles)}]: ").strip()
            try:
                idx = int(choice) - 1
                if 0 <= idx < len(profiles):
                    return profiles[idx]
            except ValueError:
                pass
            print("Invalid choice, try again.")


# --- Main ---

def main():
    parser = argparse.ArgumentParser(
        prog="voicebox",
        description="Voicebox CLI — headless TTS",
        epilog="Environment: VOICEBOX_URL, VOICEBOX_HOST, VOICEBOX_PORT",
    )
    parser.add_argument("--url", default=None, help="Server URL (overrides env vars)")
    sub = parser.add_subparsers(dest="command")

    # server
    p_server = sub.add_parser("server", help="Start the backend server")
    p_server.add_argument("--port", type=int, default=DEFAULT_PORT, help=f"Port (default: {DEFAULT_PORT})")
    p_server.add_argument("--data-dir", help="Data directory")
    p_server.add_argument("-d", "--detach", action="store_true", help="Run in background")
    p_server.add_argument("--stop", action="store_true", help="Stop a detached server")

    # voices
    sub.add_parser("voices", help="List voice profiles")

    # import
    p_import = sub.add_parser("import", help="Import a voice profile from ZIP")
    p_import.add_argument("file", help="Path to .zip file")

    # generate
    p_gen = sub.add_parser("generate", aliases=["gen", "say"], help="Generate speech")
    p_gen.add_argument("--voice", "-v", help="Voice name (interactive picker if omitted)")
    p_gen.add_argument("--text", "-t", help="Text to speak")
    p_gen.add_argument("--file", "-f", help="Read text from a file")
    p_gen.add_argument("--output", "-o", help="Output path (default: output_<epoch>.m4a)")
    p_gen.add_argument("--language", "-l", help="Language code")
    p_gen.add_argument("--seed", "-s", type=int, help="Random seed")
    p_gen.add_argument("--instruct", help="Style instruction (e.g. 'speak slowly')")
    p_gen.add_argument("--no-open", action="store_true", help="Don't open file after generating")

    # health
    sub.add_parser("health", help="Check server status")

    args = parser.parse_args()

    # Resolve URL: --url flag > VOICEBOX_URL > VOICEBOX_HOST:PORT > default
    if args.url:
        args.url = args.url.rstrip("/")
    else:
        args.url = resolve_base_url(args)

    if args.command == "server":
        cmd_server(args)
    elif args.command == "voices":
        cmd_voices(args)
    elif args.command == "import":
        cmd_import(args)
    elif args.command in ("generate", "gen", "say"):
        cmd_generate(args)
    elif args.command == "health":
        cmd_health(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
